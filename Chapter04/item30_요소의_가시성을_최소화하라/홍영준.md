### 요소의 가시성을 최소화하라

* 일반적으로 공개적으로 노출되어 있는 요소들은 공개 API 의 일부이며, 외부에서 사용할 수 있는데 이러한 요소들을 변경하면 이 코드를 사용하는 모든 부분이 영향을 받는다.
* 가시성과 관련된 제한을 변경하는 것은 더 어렵다.
* 따라서 처음에는 작은 API 로서 개발하도록 강제하는 것이 더 좋을 수 있다.

* 클래스의 상태를 나타내는 프로퍼티를 외부에서 변경할 수 있다면, 클래스는 자신의 상태를 보장할 수 없다.
* 클래스가 만족해야 하는 클래스의 상태에 대한 규약 등이 있을 수 있다. 
* 이런 규약을 모르는 사람은 클래스 상태를 마음대로 바꿀 수 있으므로 클래스 불변성이 무너질 가능성이 있다.

* 일반적으로 코틀린에서는 구체 접근자의 가시성을 제한해서 모든 프로퍼티를 캡슐화하는 것이 좋다. -> setter 만 private 로 만들기

```kotlin
class CounterSet<T>(
    private val innerSet: MutableSet<T> = setOf()
) : MutableSet<T> by innerSet {
    var elementsAdded: Int = 0
        private set
    
    override fun add(element: T): Boolean {
        elementsAdded++
        return innerSet.add(element)
    }
    
    override fun addAll(elements: Collection<T>): Boolean {
        elementsAdded += elements.size
        return innerSet.addAll(elements)
    }
}
```

* 가시성이 제한될수록 클래스의 변경을 쉽게 추적할 수 있으며, 프로퍼티 상태를 더 쉽게 이해할 수 있다.
* 이는 동시성을 처리할 때 중요하다. -> 상태 변경은 병렬 프로그래밍에서 문제가 되기 때문

### 가시성 한정자 사용하기

* 내부 변경 없이 작은 인터페이스를 유지하고 싶다면 가시성을 제한하면 된다. 
* 기본적으로 클래스, 요소를 외부에 노출할 필요가 없다면 가시성을 제한해서 외부에서 접근할 수 없게 만드는 게 좋다.

* 클래스 멤버의 경우 4개의 가시성 한정자를 쓸 수 있다. 
  * public(디폴트) : 어디서나 볼 수 있다. 
  * private : 클래스 안에서만 볼 수 있다.
  * protected : 클래스, 서브클래스 내부에서만 볼 수 있다. 
  * internal : 모듈 내부에서만 볼 수 있다.
* 톱레벨 요소에선 3가지 가시성 한정자를 쓸 수 있다. 
  * public(디폴트) : 어디서나 볼 수 있다. 
  * private : 같은 파일 안에서만 볼 수 있다. 
  * internal : 모듈 내부에서만 볼 수 있다.

* 이러한 규칙은 데이터를 저장하도록 설계된 클래스 (데이터 모델 클래스, DTO)에는 적용하지 않는 것이 좋다. 데이터를 저장하도록 설계된 클래스는 숨길 이유가 없기 때문이다.
* 한 가지 제한은 API 상속 시 오버라이드해서 가시성을 제한할 수는 없다. 이는 서브클래스가 슈퍼클래스로도 쓰일 수 있기 때문이다. 이게 상속보다 컴포지션을 선호하는 대표적인 이유다.