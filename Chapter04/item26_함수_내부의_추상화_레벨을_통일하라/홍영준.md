### 요약

* 별도의 추상화 계층을 만드는 것은 프로그래밍에서 일반적으로 사용되는 개념이다.
* 추상화를 통해 상호 운영성(interoperability)과 플랫폼 독립성을 얻을 수 있다.
* 함수 클래스 모듈 등 다양한 방식을 통해 추상화를 분리할 수 있으며 이때 각각의 레이어가 너무 커지는 것은 좋지 않다.

### 추상화 레벨

* 일반적으로 컴퓨터 과학자들은 어떤 계층이 높은 레벨인지 낮은 레벨인지를 구분한다.
* 높은 레벨로 갈수록 물리 장치로부터 멀어진다. -> 프로그래밍에서는 일반적으로 높은 레벨일수록 프로세스로부터 멀어진다고 한다.
* 높은 레벨일수록 단순함을 얻지만, 제어력을 잃는다.

### 추상화 레벨 통일

* 컴퓨터 과학이 높은 레벨과 낮은 레벨을 구분하는 것 처럼, 함수도 높은 레벨과 낮은 레벨을 구분해서 사용해야 한다는 원칙이 있다.
* 이를 추상화 레벨 통일(Single Level of Abstraction, SLA) 원칙이라고 부른다.

* 아래 코드 예시처럼 함수를 계층처럼 나눠서 사용하면 어떤 식으로 동작하는지 확실하게 알 수 있다.
* 즉, 매우 간단한 추상화를 추출해서 가독성을 크게 향상 시킬 수 있다.
* 함수는 작아야하며, 최소환의 책임만을 가져야 한다.
* 어떤 함수가 다른 함수보다 좀 복잡하다면, 일부 부분을 추출해서 추상화하는 것이 좋다.
* 함수를 추출하면, 재사용과 테스트가 쉬워진다.

#### AS-IS
```kotlin
class CoffeeMachine {
    fun makeCoffee() {
        // 수백 개의 변수 선언
        // 복잡한 로직 처리
        // 낮은 수준의 최적화 진행
    }
}
```

#### TO-BE
```kotlin
class CoffeeMachine {
    fun makeCoffee() {
        boilWater()
        brewCoffee()
        pourCoffee()
        pourMilk()
    }
    
    private fun boilWater() {
        // ...
    }

    private fun brewCoffee() {
        // ...
    }

    private fun pourCoffee() {
        // ...
    }

    private fun pourMilk() {
        // ...
    }
}
```

### 프로그램 아키텍처의 추상 레벨

* 추상화 계층이라는 개념은 함수보다 높은 레벨에서도 적용할 수 있다.
* 이러한 개념은 모듈 시스템을 설계할 때도 중요하다.
* 모듈을 분리하면 계층 고유의 요소를 숨길 수 있다.
* 애플리케이션을 만들 때는 입력과 출력을 나타내는 모듈은 낮은 레벨의 모듈이다.
* 그리고 비즈니스 로직을 나타내는 부분이 높은 레벨의 모듈이다.
* 계층이 잘 분리된 프로젝트를 계층화가 잘 되었다고 부르며 계층화가 잘 된 프로젝트는 어떤 계층 위치에서 코드를 보아도 일관적인 관점을 얻을 수 있다.

