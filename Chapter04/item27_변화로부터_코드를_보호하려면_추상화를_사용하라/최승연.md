## 27. 추상화를 통해 변화로부터 코드 보호하기

- 추상화를 사용하면 변경으로부터 코드를 보호할 수 있음
  - 의존하는 라이브러리가 변경되어도, 추상화되어 있기(프로젝트 단에서 매핑) 때문에 변경의 전이가 발생하지 않음

### 추상화 방법
- **상수**: 리터럴은 아무 의미를 나타낼 수 없지만, 상수는 이름을 통해 의미를 드러낼 수 있음
  - 2번 이상 사용하는 값은 상수로 추출
- **함수**: 외부 API, 알고리즘을 추출하여 함수로 매핑하는 형태
  - 외부 라이브러리의 변경되어도, 매핑한 함수 내부만 수정하면 됨
  - 함수의 이름을 직접적으로 변경하기는 어려움 -> 의존하는 모든 부분이 변경되기 때문, 특히 외부 모듈에서 의존 중이라면 펑~
    - 따라서 이름을 정의할 때, 최대한 수정이 없도록 조심히 골라야 함 -> 좀 더 추상적인 레벨의 이름으로 선택하자 ex) `showToast -> showMessage`
- **클래스**
  - 상태를 가지고 더 많은 함수를 가지고 있기 때문에 함수보다 더 강력한 추상화가 가능
  - 한계: 구현을 볼 수 있음, 더 많은 자유를 위해서는 인터페이스로 추상화하기
- **인터페이스**
  - 구현을 추상화하고 사용자로부터 추상화한 것에만 의존하도록 구현할 수 있음 -> 결합의 감소
  - 테스트 용이: 인터페이스 페이킹은 클래스 모킹보다 간단하며, 별도의 모킹 라이브러리가 필요 없음

### 추상화의 장단점
- 변경으로부터 자유를 주지만, 그만큼 이해가 어려움
- 다이렉트를 작성하는 것보다 추상화를 하는 것이 더 많은 비용이 소모됨 -> 모든 것을 추상화하면 안 됨
- `showMessage` 함수도 toast를 띄워주는 것인지, 스낵바를 띄워주는 것인지 한 눈에 파악하기 어려움

### 균형
- 팀과 프로젝트의 크기, 경험, feature set, 도메인 지식 등을 고려하여 추상화 수준을 맞추어야 함
- 추상화를 사용하면 좋을 때
  - 많은 개발자가 참여하는 경우
  - 테스트를 사용할 때
  - 다른 애플리케이션을 기반으로하는 새 애플리케이션을 제작할 때
- 작고 실험적인 프로젝트라면, 추상화보단 구현을 우선으로 하자
- 의존성 프레임워크를 사용하면 생성의 복잡성은 고려하지 않아도 괜찮다 (DI 프레임워크에서 다 처리해줌)