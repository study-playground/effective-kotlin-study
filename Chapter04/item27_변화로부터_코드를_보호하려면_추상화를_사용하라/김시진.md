## 아이템27. 변화로부터 코드를 보호하려면 추상화를 사용하라
함수와 클래스 등의 추상화로 실질적인 코드를 숨기면, 사용자가 세부 사항을 알지 못해도 괜찮다는 장점이 있습니다.

### 상수
- 리터럴은 아무것도 설명하지 않습니다.
- 코드에서 반복적으로 등장할 때 문제가 됩니다.
- 상수 프로퍼티로 변경하면 해당 값에 의미 있는 이름을 붙일 수 있으며, 상수의 값을 변경해야 할 때 훨씬 쉽게 변경할 수 있습니다.

ex) MIN_PASSWORD_LENGTH = 7

### 함수 
- 많이 사용되는 알고리즘은 확장 함수로 만들어서 사용할 수 있습니다.


```kotlin
fun Context.toast(
	message : String,
    duration : Int = Toast.LENGTH_LONG
) {
	Toast.makeText(this, message, duration).show()
}
```

- 토스트를 출력하는 방법이 변경되어도, 확장 함수 부분만 수정하면 되므로 유지보수성이 향상됩니다.
- 만약 다른 형태의 방식으로 출력해야 한다면, 어떻게 해야 할까요?
- 함수의 이름을 직접 바꾸는 것은 위험할 수 있습니다.
- 다른 모듈이 이 함수에 의존하고 있다면, 다른 모듈에 큰 문제가 발생할 것입니다.
- 파라미터는 한꺼번에 바꾸기가 쉽지 않으므로, 메시지의 지속시간을 나타내기 위한 Toast.LENGTH_LONG이 계속 사용되고 있다는 문제도 있습니다.
- 함수는 추상화를 표현하는 수단이며, 함수 시그니처는 이 함수가 어떤 추상화를 표현하고 있는지 알려 줍니다.
- 의미 있는 이름은 굉장히 중요합니다.
- 함수는 매우 단순한 추상화지만, 제한이 많습니다.
- 상태를 유지하지 않습니다.


### 클래스
- 클래스가 함수보다 더 강력한 이유는 상태를 가질 수 있으며, 많은 함수를 가질 수 있다는 점 때문입니다.
- 의존성 주입 프레임워크를 사용하면, 클래스 생성을 위임할 수도 있습니다.
- mock 객체를 활용해서 해당 클래스에 의존하는 다른 클래스의 기능을 테스트할 수 있습니다.
- 메시지를 출력하는 더 다양한 종류의 메서드를 만들 수도 있습니다.
- 여전히 한계는 존재합니다. final이라면, 해당 클래스 타입 아래에 어떤 구현이 있는지 알 수 있습니다.
- open 클래스를 활용하면 조금은 더 자유를 얻을 수 있습니다.


### 인터페이스
- 라이브러리를 만드는 사람은 내부 클래스의 가시성을 제한하고, 인터페이스를 통해 이를 노출하는 코드를 많이 사용합니다.
- 인터페이스 뒤에 객체를 숨김으로써 실질적인 구현을 추상화하고, 사용자가 추상화된 것에만 의존하게 만들 수 있는 것입니다.
- coupling을 줄일 수 있는 것입니다.
- faking이 mocking보다 간단하므로 테스트할 때 좋습니다.
- 선언과 사용이 분리되어 있으므로, 변경에 자유롭습니다.

### 추상화가 주는 자유

추상화를 하는 방법
- 상수로 추출
- 동작을 함수로 래핑
- 함수를 클래스로 래핑
- 인터페이스 뒤에 클래스를 숨긴다
- 특수한 객체로 래핑한다


### 추상화의 문제
- 코드를 읽는 사람이 해당 개념을 배우고, 잘 이해해야 합니다.
- 추상화도 비용이 발생합니다.
- 추상화는 많은 것을 숨길 수 있는 테크닉입니다. 생각할 것을 어느 정도 숨겨야 개발이 쉬워지는 것도 사실이지만 너무 많은 것을 숨기면 결과를 이해하는 것 자체가 어려워집니다.

### 어떻게 균형을 맞춰야 할까?
- 팀의 크기
- 팀의 경험
- 프로젝트의 크기
- feature 세트
- 도메인 지식

위와 같은 요소들을 고려해야 합니다.

- 많은 개발자가 참여하는 프로젝트는 이후에 객체 생성과 사용 방법을 변경하기 어렵습니다. 따라서 추상화 방법을 사용하는 것이 좋습니다. 최대한 모듈과 부분을 분리하는 것이 좋습니다.
- DI 프레임워크를 사용하면, 생성이 얼마나 복잡한지는 신경 쓰지 않아도 됩니다.
- 테스트를 하거나, 다른 애플리케이션을 기반으로 새로운 애플리케이션을 만든다면 추상화를 사용하는 것이 좋습니다.
- 프로젝트가 작고 실험적이라면, 추상화를 하지 않고도 직접 변경해도 괜찮습니다.

