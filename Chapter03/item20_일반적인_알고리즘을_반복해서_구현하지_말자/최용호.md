## 20. 일반적인 알고리즘을 반복해서 구현하지 말라
많은 개발자는 같은 알고리즘을 여러 번 반복해서 구현한다.

```kotlin
val percent = when {
    numberFromUser > 100 -> 100
    numberFromUser < 0 -> 0
    else -> numberFromUser
}
```

해당 알고리즘은 stdlib의 coerceIn 확장 함수로 이미 존재한다. 따라서 구현하지 않아도 된다.

```kotlin
val percent = numberFromUser.coerceIn(0, 100)
```

### 이미 존재하는 알고림즘을 사용했을 때 장점
- 코드 작성 속도가 빨라진다.
- 구현을 따로 읽지 않아도, 함수의 이름 등만 보고도 무엇을 하는지 확실하게 알 수 있다.
- 직접 구현할 때 발생할 수 있는 실수를 줄일 수 있다.
- 제작자들이 한 번만 최적화하면, 이러한 함수를 활용하는 모든 곳이 최적화의 혜택을 받을 수 있다.

### 나만의 유틸리티 구현하기
상황에 따라서 표준 라이브러리에 없는 알고리즘이 필요할 수도 있다.

```kotlin
fun Interable<Int>.product() = 
    fold(1) { acc, i -> acc * i }
```

많이 사용되는 알고리즘을 추출하는 방법으로는 톱레벨 함수, 프로퍼티 위임, 클래스 등이 있다. 확장 함수는 이러한 방법들과 비교해서, 다음과 같은 장점을 갖고 있다.

- 함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋다.
- 톱레벨 함수와 비교해서, 확장 함수는 구체적인 타입이 있는 객체에만 사용을 제안할 수 있어서 좋다.
- 수정할 객체를 아규먼트로 전달받아 사용하는 것보다는 확장 리시버로 사용하는 것이 가독성 측면에서 좋다
- 확장 함수는 객체의 정의한 함수보다 객체를 사용할 때, 자동 완성 기능 등으로 제안이 이루어지므로 쉽게 찾을 수 있다.

```kotlin
fun main() {
    TextUtils.isEmpty("Text")
		"Text".isEmpty() // 더 사용하기 쉽다.
}
```

대부분의 경우에는 [stdlib](https://kotlinlang.org/api/latest/jvm/stdlib/)에 이미 정의되어 있을 가능서이 높으니 stdlib를 확인해보면 좋다.
