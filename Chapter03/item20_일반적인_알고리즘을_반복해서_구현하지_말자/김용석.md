# Item 20 : Do not repeat common algorithms

개발자들은 종종 일반적인 문제를 해결하기 위해, 특정 코드 패턴이나 알고리즘을 구현하려는 경향이 있다.
이런 코드 패턴이나 알고리즘은 비지니스 로직과 별개로, 수학적 연산이나 컬렉션 처리와 같은 일반적인 기능 수행 등 다양한 형태로 나타난다.

이때, 필요한 기능이 이미 '표준 라이브러리'로 제공되고 있다면, 직접 구현하는 것은 불필요한 행동이다.  
그럼에도, 짧지만 반복되는 알고리즘을 함수로 추출하는 접근 방식은 개발 프로세스의 여러 측면에서 이점을 제공한다.

1. 함수 호출 1번으로 훨씬 간결한 코드 작성을 하기에 프로그래밍 속도가 향상된다.
2. 알고리즘이 함수 이름으로 명시되어 있어, 구현을 하나하나 이해하지 않아도 해당 기능을 바로 알 수 있다.
3. 불필요한 정보가 최소화되어, 코드 내 특이점(오류 상황, 비정상 로직 등)을 파악하기 쉬워진다.
4. 한 번의 최적화로 모든 사용처에 성능 향상 이점을 볼 수 있다.

'표준 라이브러리'는 대부분의 일반적인 알고리즘을 '확장 함수'로 제공하고 있으며, 다양한 유틸리티의 거대한 집합으로 정의된다.  
이 때문에 표준 라이브러리 함수들을 학습하는 것은 까다롭지만, 매우 가치 있는 일이다.

## Implementing your own utils

그럼에도, 모든 프로젝트에는 표준 라이브러리가 제공하지 않는 특정 알고리즘이 필요한 순간들이 있다.  
이런 경우에는 널리 알려진 함수들을 활용하여, 보편적인 유틸리티 함수로 정의하는 것이 좋다.

아래는 컬렉션에 있는 숫자의 곱을 계산하는 함수를 정의한 예시이다.

```kotlin
fun Iterable<Int>.product() = fold(1) { acc, i -> acc * i }
```

또한 보편적인 유틸리티 함수를 정의할 때, 이미 잘 알려진 수학적 개념을 미리 구현하는 것도 좋다.
이런 수학적 개념들은 이름 자체가 이미 명확하기에, 먼 미래에 다른 개발자가 해당 함수를 필요로 할 때, 미리 구현되어 있다면 큰 도움을 받을 것이다.

이 때, **주의할 점은 동일한 결과를 얻는 중복 함수**를 만드는 것이다.  
각 함수들은 반드시 테스트되고, 개발자들이 기억하고 있어야 하며, 유지보수 되어야 하기에 비용으로 간주된다.  
만약, 함수를 무분별하게 추가하게 되면 이 비용이 계속해서 증가함으로, 필요한 함수가 이미 존재하는지 확인하는 것이 중요하다.

개발자들은 'top-level function', 'property delegate', 'class'에 이르기까지, 다양한 방법으로 공통 알고리즘을 추출할 수 있다.
그럼에도 불구하고, 표준 라이브러리와 같이 대부분 함수를 '확장 함수'로 정의하는 이유는 다음과 같다.

1. 함수는 상태를 필요로 하지 않기에, 'Side-effect'가 없는 행동을 표현하는데 적합하다.
2. 함수의 파라미터를 수정하는 것보다, 리시버를 수정하는 것이 더 직관적이다.
3. 객체의 메서드에 비해, 객체에만 '제안'되기에 '힌트' 중에서 찾기 더 쉽다.  
   예를 들어, `TextUtils.isEmpty("Text")` 보다 `"Text".isEmpty()`가 더 찾기 쉽다.
4. '확장 함수'는 명확한 호출 컨텍스트를 제공하기에, 'class / super class의 메서드' 또는 'top-level function'과의 혼동을 줄일 수 있다.
