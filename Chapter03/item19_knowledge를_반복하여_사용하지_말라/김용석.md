# Item 19 : Do not repeat knowledge

프로그래밍에서 'knowledge'를 표현하면 다음과 같다.

- 의도적으로 생성된 모든 '정보 조각'을 의미하며, 코드 또는 데이터로 표현된다.
- 코드 또는 데이터가 없는 경우에는, 기본 동작을 사용하고 싶다는 의미로 나타낼 수 있다.
    - e.g : 상속을 받고 메서드를 'override' 하지 않을 때, 해당 메서드가 상위 클래스와 동일하게 동작하기를 원하는것으로 나타낼 수 있다.

소프트웨어에서 'knowledge'는 '알고리즘', 'UI 디자인' 등이 될 수 있으며, 다음과 같은 방식으로 표현될 수 있다.

- 코드 : 가장 직접적인 표현 방식, 함수•클래스•변수 등을 통해 구체적인 동작과 로직을 표현
- 구성 : 앱의 동작 환경을 정의하는 방식, 런타임에 프로그램의 행동 조정 가능
- 템플릿 : 문서•UI 레이아웃•코드 구조 등 미리 정의하여 재사용 가능한 형태로 만들 수 있음

결과적으로, 프로그램은 어떤 형태로든 'knowledge'를 보유하고 있으며, 다음 두 가지 'knowledge'를 중요하게 생각한다.

- 로직 : 프로그램의 동작 방식과 UI 디자인에 대한 예상
- 공통 알고리즘 : 기대하는 동작을 달성하기 위해 구현한 알고리즘

## Everything can change

프로그래밍에서 유일한 상수는 '변화'라는 말이 있다.  
5 ~ 10년 전의 서비스들을 살펴보면, 변경되지 않는 앱 또는 웹사이트가 있는지 생각해보면 많이 없을 것이다.  
또한, Android OS도 08년에 처음 출시되어, 'Vanilla'까지 계속 업데이트 되고 있고,
Kotlin도 16년도에 1.0 버전 출시 후 계속 업데이트 되어 2.0 안정화 출시를 앞두고 있다.

이러한 변화는 UI 디자인과 기술에서 더욱 빠르게 발생하며, 이에 맞춰 사용자들의 요구사항도 빈번하게 변경되고 달라진다.  
이는 곧, 기존의 서비스들이 계속해서 사용자 요구사항에 맞춰 업데이트 되어야 함을 의미한다.  
결과적으로, 현대의 S/W 개발은 기술의 발전, 경쟁 상대의 변화, 사용자 피드백 등 여러 요인에 의해 '지속적인 변화'가 필수적임을 알 수 있다.

이러한 변화에 가장 큰 문제점 중 하나는 '반복되는 knowledge'이다.  
예를 들어, 프로젝트 내 전역적으로 사용되는 버튼의 디자인이 변경된다면 모든 위치의 디자인을 바꾸는 것은 번거롭고 실수를 유발할 수 있다.
또한, DB 테이블 이름이 바뀌는 경우, 모든 SQL문에 맞게 수정되지 않으면 큰 문제가 발생할 수 있다.

이러한 문제를 선임 개발자들이 일찍이 인지하고, 이를 해결하기 위해 다양한 도구와 기능을 만들었다.  
전역적으로 사용되는 버튼은 Style Pattern, Custom View, Component 등을 통해 해결할 수 있고,
텍스트 형식의 SQL문 대신 ORM, DAO를 사용하여 해결할 수 있다.

이러한 해결법들은 다양한 종류의 추상화를 나타내며, 프로젝트를 다양한 종류의 중복성으로부터 보호한다.

## When should we allow code repetition?

비슷해 보이는 코드 블록이 있을지라도, 실제로 동일한 기능을 수행하거나 동일한 문제를 해결하는 것은 아니다.  
이처럼 각 코드가 다른 목적으로 사용될 수 있기에, 동일해 보이는 코드를 무작정 하나로 추출하여 재사용하는 것은 안된다.

예를 들어, 같은 프로젝트에 두 개의 독립적인 안드로이드 앱이 있다고 가정해보자.  
두 앱은 비슷한 'Build configuration'을 갖지만, 각 앱은 독립적인 요구사항과 개발 사이클을 지닌다.  
이때, 각 'Build configuration'을 무작정 하나의 'common configuration'으로 만들면 다음과 같은 문제가 발생할 수 있다.

- 한 앱에서 'Configuration'의 변경이 필요한 경우, 다른 앱에 영향을 주기에 관리의 복잡성이 증가한다.
- 새로운 방식의 'common configuration'이 도입되어, 개발자들이 다시 패턴과 규칙을 만들어 지켜야하는 비용이 발생한다.

이처럼, 공통 로직으로 추출하는 것은 각 코드 블록들이 **향후에 어떻게 변경될 가능성이 있는지에 대한 고려**가 필요하다.

- 동일한 비지니스 로직 또는 요구사항에 영향을 받으면, 함께 변경될 가능성이 높기에 공통 로직으로 추출하는 것이 효율적이다.
- 비슷하지만 서로 다른 목적으로 사용되는 경우, 별도로 변경될 가능성이 높기에 강제로 공통 로직으로 추출하는 것은 향후 유지보수를 어렵게 하고, 프로젝트의 유연성을 떨어뜨릴 수 있다.

## Single responsibility principle

프로젝트에서의 '변화'는 다양한 관점에서 주도할 수 있으며, 이는 '관리자 • 개발자 • 외부 시스템' 등에서 발생 할 수 있다.  
이처럼 클래스나 모듈에 변경을 요구하는 어떠한 외부 요소를 '**액터**'라고 한다.  
만약, 액터가 여럿인 경우에 각각의 요구사항들이 충돌할 수 있기에, 이러한 상황을 피해야 한다.

SRP는 '클래스가 **변경**되어야 하는 이유는 **단 하나의 이유**여야 한다'는 원칙을 가지며,
위 상황에 접목하면 '2명 이상의 액터가 동일한 클래스를 변경하는 상황이 없어야 한다.'로 간소화 할 수 있다.

이처럼 SRP는 공통 로직으로 추출하지 말아야하는 상황을 판단하는데 도움을 줄 수 있으며, 아래 예시를 보자.  
대학에서 '장학 부서'와 '인증 부서'가 각각의 목적으로 '학생 정보'를 사용한다고 가정해보면 다음과 같이 사용할 수 있을 것이다.

```kotlin
class Student {
    // 인증 부서 - 학생의 합격 유무
    fun isPassing(): Boolean =
        calculatePointsFromPassedCourses() > 60

    // 장학 부서 - 학생의 장학금 자격 유무
    fun qualifiesForScholarship(): Boolean =
        calculatePointsFromPassedCourses() > 80
  
    // 지난 학기의 점수 계산
    private fun calculatePointsFromPassedCourses(): Int {
        // ...
    }
}
```

그런데, 어느날 장학금 기준이 변경되어, 일부 과목을 제외하기로 결정하였다.  
이에 따라, '장학 부서' 개발자는 '지난 학기의 점수를 계산하는 함수' 수정이 필요한 상황이다.  
그러나, 이러한 수정은 의도치 않게 '인증 부서'에도 영향을 줄 수 있기에, 곤란한 상황이 발생하게 된다.

이처럼, 같은 클래스나 파일 내 위치한 두 기능이 서로 강하게 의존되어 있으면 문제가 되는 상황이 많이 발생할 수 있다.  
이를 위해, 기능이나 역할을 별도의 클래스로 추출하여 독립적으로 변경될 수 있도록 하여 문제를 해결할 수 있다.

위 예시를 통해 알 수 있는 것은, '서로 다른 출처'에서 오는 'knowledge'는 독립적으로 변할 수 있기에 'different knowledge'로 다루어야 한다.
또한, 이러한 'different knowledge'를 분리하지 않으면, 재사용이 가능한 부분과 그렇지 않은 부분으로 구별하는 것이 어려워지고, 재사용되서는 안되는 부분을 재사용하게 되는 실수가 발생될 수 있다.
