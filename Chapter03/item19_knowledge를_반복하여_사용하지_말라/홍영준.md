### knowledge 를 반복하여 사용하지 말라

> 프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가 잘못된 것이다.

* 책에서는 이를 'knowledge 를 반복하여 사용하지 말라' 라는 규칙으로 표현하고 있다.

### knowledge
* knowledge 는 코드 또는 데이터로 표현할 수 있다.
* 즉, 프로젝트를 진행할 때 정의한 모든 것이 knowledge 이다.
* knowledge 의 종류는 알고리즘의 작동방식, UI 의 형태, 우리가 원하는 결과 등 다양하다.

* 프로그램에서 중요한 knowledge 를 두 가지 뽑는다면 다음과 같다.

1. 비즈니스 로직 : 프로그램이 어떠한 식으로 동작하는지와 프로그램이 어떻게 보이는지
2. 공통 알고리즘 : 원하는 동작을 하기 위한 알고리즘

* 비즈니스 로직은 시간이 지나면서 계속해서 변하지만, 공통 알고리즘은 한 번 정의된 이후에는 크게 변하지 않는다.

### 모든 것은 변화한다.
* 프로그래밍에서 유일하게 유지되는 것은 '변화한다는 속성'이라는 말이 있을 정도로 많은 프로젝트에서 변화가 일어난다.
* 대부분 프로젝트는 몇 달마다 요구 사항과 내부적인 구조를 계속해서 변경한다. -> 널리 사용되는 관리 시스템은 애자일하며, 요구 사항의 변화를 맞추는 데 적합하다.
* 모든 것은 변화하고, 우리는 이에 대비해야 한다.
* 변화할 때 가장 큰 걸림돌은 knowledge 가 반복되어 있는 부분이다.

* 프로그램 내부에서 여러 부분에 반복되어 있는 코드를 변경하려면 반복된 모든 부분을 찾고, 모두 변경하면 된다.
* 하지만 변경 과정에서 실수가 발생할 수 있다. -> 이는 큰 장애로 이어질 수 있다.
* 예를 들어, 데이터베이스 테이블 내부 이름을 변경하면 이 테이블에 의존하는 모든 SQL 구문을 변경해야 한다. 만약 한 부분이라도 수정하는 것을 잊는다면 큰 장애가 발생할 수 있다.

* knowledge 반복은 프로젝트의 확장성(scalable)을 막고, 쉽게 깨지게(fragile) 만든다.
* 여러 종류의 추상화를 표현할 수 있는 수 많은 솔루션들이 있으며, 이를 활용하면 반복을 줄일 수 있다. (ex. Hibernate - ORM, Exposed - DAO)

### 언제 코드를 반복해도 될까 ?
* 얼핏보면 knowledge 반복처럼 보이지만, 실질적으로 다른 knowledge 를 나타낼 때는 반복을 줄이면 안된다.
* 예를 들어, 어떤 프로젝트에서 독립적인 2개의 안드로이드 애플리케이션을 만들고 있을 때 빌드 도구 설정이 비슷할 것이므로, 이를 추출해서 knowledge 반복을 줄일 수 있다. 하지만 두 애플리케이션은 독립적이므로 구성 변경이 일부 필요할 수도 있고, 한 쪽 구성만 변경이 필요해진다면 문제가 된다.
* 두 코드가 같은 knowledge 를 나타내는지, 다른 knowledge 를 나타내는지는 '함께 변경될 가능성이 높은가? 또는 따로 변경될 가능성이 높은가?' 라는 질문으로도 어느 정도 결정할 수 있다.
* 또한, 잘못된 코드 추출로부터 우리를 보호할 수 있는 규칙인 '단일 책임 원칙'도 있다.

### 단일 책임 원칙
* 코드의 반복을 줄일지 말지 확인할 수 있는 원칙으로, SOLID 원칙 중 하나의 단일 원칙 책임이 있다.
* Robert C. Matin 은 서로의 업무와 분야에 대해서 잘 모르는 개발자들이 같은 클래스를 변경하는 일은 없어야 한다고 말한다.
* 단일 책임 원칙은 2가지 사실을 알려준다.
  * 서로 다른 곳에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많다. 따라서 비슷한 처리를 하더라도 완전히 다른 knowledge 로 취급하는 것이 좋다.
  * 다른 knowledge 는 분리해 두는 것이 좋다. 그렇지 않으면 재사용해서는 안 되는 부분을 재사용하려는 유혹이 발생할 수 있다.

### 단일 책임 원칙 예시

```kotlin
class Student {
    // ...
    
    // 인증 관련 부서에서 만든 프로퍼티로, 학생이 인증을 통과했는지를 나타낸다.
    fun isPassing(): Boolean = calculate() > 15
    
    // 장학금 관련 부서에서 만든 프로퍼티로, 학생이 장학금을 받을 수 있는 포인트를 가지고 있는지를 나탄낸다.
    fun qualifiesForScholarShip(): Boolean = calculate() > 30
}
```

* 위 코드가 있다고 가정한다.
* 요구사항이 '덜 중요한 과목은 장학금 포인트 기준을 줄여달라' 라고 새롭게 요구되었다면, 이것을 변경하기 위한 새로운 개발자가 qualifiesForScholarShip 프로퍼티를 확인하고, calculate() 함수를 수정할 것 이다.
* 그런데 의도하지않게 같은 함수를 사용하는 isPassing() 도 동작을 수정하면 인증을 통과할 줄 알았던 학생이 인증을 통과하지 못할수도 있다.
* 이러한 문제를 방지하려면, 처음부터 책임에 따라 다른 클래스로 구분해서 만들어야한다.

